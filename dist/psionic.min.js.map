{"version":3,"sources":["webpack:///psionic.min.js","webpack:///webpack/bootstrap 1995fc6ad765e8bd4116","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///./lib/browser.js","webpack:///./lib/shared.js","webpack:///./lib/websocket-browser/client.js","webpack:///./lib/websocket-browser/index.js","webpack:///./~/eventemitter2/lib/eventemitter2.js","webpack:///./lib/browser.js?c62a","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","process","global","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$utils$$isMaybeThenable","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","node","document","createTextNode","observe","characterData","data","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","setTimeout","i","lib$es6$promise$asap$$len","callback","lib$es6$promise$asap$$queue","arg","undefined","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","e","lib$es6$promise$$internal$$noop","lib$es6$promise$$internal$$selfFulfillment","TypeError","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","promise","then","error","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","value","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","_state","lib$es6$promise$$internal$$FULFILLED","_result","lib$es6$promise$$internal$$REJECTED","lib$es6$promise$$internal$$subscribe","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","constructor","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","length","parent","child","onFulfillment","onRejection","subscribers","settled","detail","lib$es6$promise$$internal$$invokeCallback","lib$es6$promise$$internal$$ErrorObject","this","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$enumerator$$Enumerator","Constructor","input","enumerator","_instanceConstructor","_validateInput","_input","_remaining","_init","_enumerate","_validationError","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","resolve","lib$es6$promise$promise$resolve$$resolve","object","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","_id","lib$es6$promise$promise$$counter","lib$es6$promise$polyfill$$polyfill","local","self","Function","Error","P","Promise","Object","prototype","toString","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","Array","isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","window","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","_eachEntry","entry","_settledAt","_willSettleAt","state","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$resolve$$default","lib$es6$promise$promise$reject$$default","all","race","reject","_setScheduler","_setAsap","_asap","result","arguments","catch","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","webSocket","serializeDescription","description","JSON","parse","stringify","key","FN_KEYWORD","deserializeDescription","client","createInvokers","obj","prefix","keys","forEach","createRpcInvoker","name","awaits","awaitConnection","connected","once","args","json","callId","slice","ex","onResult","removeListener","onClose","message","code","emit","onMessage","msg","wrapInvocation","target","parts","split","describe","apply","friendlyMessage","substring","console","stack","EventEmitter","EventEmitter2","createClient","opts","protectedKeys","events","setMaxListeners","close","desc","remoteDescription","indexOf","on","shared","clientOpts","socket","reconnecting","closing","backoff","send","createSocket","WebSocket","onopen","connect","onclose","Math","min","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","searchListenerTree","handlers","type","tree","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","listeners","typeLength","currentType","nextType","_listeners","push","hasOwnProperty","concat","**","growListenerTree","listener","shift","warned","defaultMaxListeners","trace","n","event","fn","many","ttl","off","_origin","_all","l","handler","ns","onAny","addListener","leafs","iLeaf","position","splice","offAny","fns","removeAllListeners","listenersAny","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","array","noop","title","browser","env","argv","version","versions","binding","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths","children"],"mappings":"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","file":"psionic.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.0.2\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$toString = {}.toString;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(11);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$es6$promise$utils$$isArray(input);\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t\n\t      var length  = enumerator.length;\n\t      var promise = enumerator.promise;\n\t      var input   = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t\n\t      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          entry._onerror = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = entry;\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n\t          lib$es6$promise$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n\t          lib$es6$promise$promise$$needsNew();\n\t        }\n\t\n\t        lib$es6$promise$$internal$$initializePromise(this, resolver);\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t          return this;\n\t        }\n\t\n\t        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t        var result = parent._result;\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$es6$promise$asap$$asap(function(){\n\t            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), (function() { return this; }()), __webpack_require__(10)(module)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = {\n\t  webSocket: __webpack_require__(5)\n\t};\n\t\n\t\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar Promise = typeof global.Promise === 'undefined' ? __webpack_require__(1).Promise : global.Promise;\n\tvar EventEmitter = __webpack_require__(6);\n\tif (EventEmitter.EventEmitter2) EventEmitter = EventEmitter.EventEmitter2;\n\tvar FN_KEYWORD = 'psionic!function';\n\tvar slice = Array.prototype.slice;\n\t\n\texports.createClient = function createClient(opts) {\n\t  var client = {}, protectedKeys = null;\n\t  client.events = new EventEmitter();\n\t  client.state = new EventEmitter();\n\t  client.state.setMaxListeners(100);\n\t  client.state.callId = 0;\n\t  client.state.describe = opts ? opts.describe : undefined;\n\t  client.close = function () { client.state.emit('close'); }\n\t\n\t  client.state['@describe'] = function parseIncomingDescription(desc) {\n\t    var remoteDescription = deserializeDescription(client, desc || {});\n\t    Object.keys(client).forEach(function (key) {\n\t      if (protectedKeys.indexOf(key) === -1) {\n\t        delete client[key];\n\t      }\n\t    });\n\t    Object.keys(remoteDescription).forEach(function (key) {\n\t      if (protectedKeys.indexOf(key) === -1) {\n\t        client[key] = remoteDescription[key];\n\t      }\n\t    });\n\t    client.state.emit('describe');\n\t  };\n\t\n\t  client.state['@emit'] = function () {\n\t    client.events.emit.apply(client.events, arguments);\n\t  };\n\t\n\t  client.emit = createRpcInvoker(client, '@emit');\n\t\n\t  client.describe = function (value) {\n\t    client.state.describe = value;\n\t    return createRpcInvoker(client, '@describe')(serializeDescription(value));\n\t  };\n\t\n\t  client.state.on('open', function () {\n\t    return createRpcInvoker(client, '@describe', false)(serializeDescription(client.state.describe));\n\t  });\n\t\n\t  client.state.on('message', function(msg) { onMessage(client, msg); });\n\t  protectedKeys = Object.keys(client);\n\t  client.state['@describe']();\n\t  return client;\n\t};\n\t\n\tfunction serializeDescription(description) {\n\t  if (!description) return;\n\t  return JSON.parse(JSON.stringify(description, function (key, value) {\n\t    if (value instanceof Function) return FN_KEYWORD;\n\t    return value;\n\t  }));\n\t};\n\t\n\tfunction deserializeDescription(client, description) {\n\t  return (function createInvokers(obj, prefix) {\n\t    Object.keys(obj).forEach(function (key) {\n\t      if (obj[key] === FN_KEYWORD) {\n\t        obj[key] = createRpcInvoker(client, prefix + key);\n\t      } else if (typeof obj[key] === 'object') {\n\t        createInvokers(obj[key], prefix + key + '.');\n\t      }\n\t    });\n\t    return obj;\n\t  })(description, '');\n\t};\n\t\n\tfunction createRpcInvoker(client, name, awaits) {\n\t  function awaitConnection() {\n\t    if (awaits === false) return Promise.resolve(true);\n\t    if (client.state.connected) return Promise.resolve(true);\n\t    else return new Promise(function (resolve) { client.state.once('connect', resolve); });\n\t  }\n\t\n\t  return function rpc() {\n\t    var id, args, json;\n\t    try {\n\t      id = client.state.callId = (client.state.callId + 1) % (-(1<<31));\n\t      args = Array.prototype.slice.call(arguments);\n\t      json = { id: id, name: name, args: args };\n\t    } catch(ex) { return Promise.reject(ex); }\n\t\n\t    return awaitConnection().then(function () {\n\t      return new Promise(function (resolve, reject) {\n\t        client.state.once('disconnect', onClose);\n\t        client.state.once('result:' + id, onResult);\n\t        client.state.emit('send', json);\n\t        function onResult(data) {\n\t          client.state.removeListener('disconnect', onClose);\n\t          if (!data.error) return resolve(data.result);\n\t          var error = new Error('when calling ' + name + ': ' + data.error.message);\n\t          error.code = data.error.code;\n\t          reject(error);\n\t        }\n\t        function onClose() {\n\t          client.state.removeListener('result:' + id, onResult);\n\t          reject(new Error('connection disconnect'));\n\t        }\n\t      });\n\t    });\n\t  }\n\t};\n\t\n\tfunction onMessage(client, msg) {\n\t  var data = null;\n\t  try {\n\t    data = JSON.parse(msg.substring ? msg : msg.data);\n\t  } catch (ex) {\n\t    client.state.emit('send', { error: { code: -32700, message: ex.message } });\n\t    return;\n\t  }\n\t\n\t  if (!('name' in data)) {\n\t    client.state.emit('result:' + data.id, data);\n\t  } else {\n\t    wrapInvocation(data.name, data.args)\n\t    .then(function (result) {\n\t      client.state.emit('send', { id: data.id, result: result });\n\t    }, function (ex) {\n\t      typeof console !== 'undefined' && console.error(ex.stack);\n\t      client.state.emit('send', { id: data.id, error: { code: ex.code || -32000, message: ex.friendlyMessage || 'Unhandled error' } });\n\t    });\n\t  }\n\t\n\t  function wrapInvocation(name, args) {\n\t    return new Promise(function (resolve, reject) {\n\t      var target = null\n\t      if (name[0] === '@' && client.state[name]) {\n\t        target = client.state[name];\n\t      } else {\n\t        var parts = (name || '').split('.');\n\t        var target = client.state.describe || {};\n\t        for (var i=0; target && i<parts.length; ++i) {\n\t          target = target[parts[i]];\n\t        }\n\t      }\n\t      if (!(target instanceof Function)) {\n\t        var error = new Error('Function not found: ' + name);\n\t        error.friendlyMessage = error.message;\n\t        error.code = -32601;\n\t        reject(error);\n\t      } else {\n\t        try { resolve(target.apply(client, args)); }\n\t        catch (ex) { reject(ex); }\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar Promise = typeof global.Promise === 'undefined' ? __webpack_require__(1).Promise : global.Promise;\n\tvar shared = __webpack_require__(3);\n\t\n\tmodule.exports = function connect(opts, clientOpts) {\n\t  return new Promise(function (resolve, reject) {\n\t    var backoff = 0, socket, reconnecting, closing;\n\t    var client = shared.createClient(clientOpts);\n\t    client.close = function () { closing = true; if (socket) socket.close(); };\n\t    client.state.on('send', function(msg) { socket.send(JSON.stringify(msg)); });\n\t\n\t    (function createSocket() {\n\t      socket = new WebSocket(opts);\n\t      socket.onmessage = function (msg) {\n\t        client.state.emit('message', msg.data);\n\t      };\n\t\n\t      socket.onopen = function () {\n\t        if (closing) return socket.close();\n\t        backoff = 0;\n\t        client.state.emit('open');\n\t        client.state.once('describe', function() {\n\t          client.state.connected = true;\n\t          Promise.resolve(opts.connect instanceof Function ? opts.connect(client, reconnecting) : null)\n\t            .then(function () {\n\t              client.state.emit('connect');\n\t              resolve(client);\n\t            });\n\t          reconnecting = true;\n\t        });\n\t      };\n\t\n\t      socket.onclose = function () {\n\t        if (closing) client.state.emit('close');\n\t        client.state.connected = false;\n\t        client.state.emit('disconnect');\n\t        if (closing) return;\n\t        setTimeout(createSocket, 100 * (backoff * 20));\n\t        backoff = Math.min(backoff + 1, 5);\n\t      }\n\t    })();\n\t  });\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.connect = __webpack_require__(4);\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * EventEmitter2\n\t * https://github.com/hij1nx/EventEmitter2\n\t *\n\t * Copyright (c) 2013 hij1nx\n\t * Licensed under the MIT license.\n\t */\n\t;!function(undefined) {\n\t\n\t  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n\t    return Object.prototype.toString.call(obj) === \"[object Array]\";\n\t  };\n\t  var defaultMaxListeners = 10;\n\t\n\t  function init() {\n\t    this._events = {};\n\t    if (this._conf) {\n\t      configure.call(this, this._conf);\n\t    }\n\t  }\n\t\n\t  function configure(conf) {\n\t    if (conf) {\n\t\n\t      this._conf = conf;\n\t\n\t      conf.delimiter && (this.delimiter = conf.delimiter);\n\t      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n\t      conf.wildcard && (this.wildcard = conf.wildcard);\n\t      conf.newListener && (this.newListener = conf.newListener);\n\t\n\t      if (this.wildcard) {\n\t        this.listenerTree = {};\n\t      }\n\t    }\n\t  }\n\t\n\t  function EventEmitter(conf) {\n\t    this._events = {};\n\t    this.newListener = false;\n\t    configure.call(this, conf);\n\t  }\n\t\n\t  //\n\t  // Attention, function return type now is array, always !\n\t  // It has zero elements if no any matches found and one or more\n\t  // elements (leafs) if there are matches\n\t  //\n\t  function searchListenerTree(handlers, type, tree, i) {\n\t    if (!tree) {\n\t      return [];\n\t    }\n\t    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n\t        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n\t    if (i === typeLength && tree._listeners) {\n\t      //\n\t      // If at the end of the event(s) list and the tree has listeners\n\t      // invoke those listeners.\n\t      //\n\t      if (typeof tree._listeners === 'function') {\n\t        handlers && handlers.push(tree._listeners);\n\t        return [tree];\n\t      } else {\n\t        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n\t          handlers && handlers.push(tree._listeners[leaf]);\n\t        }\n\t        return [tree];\n\t      }\n\t    }\n\t\n\t    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n\t      //\n\t      // If the event emitted is '*' at this part\n\t      // or there is a concrete match at this patch\n\t      //\n\t      if (currentType === '*') {\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n\t          }\n\t        }\n\t        return listeners;\n\t      } else if(currentType === '**') {\n\t        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n\t        if(endReached && tree._listeners) {\n\t          // The next element has a _listeners, add it to the handlers.\n\t          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n\t        }\n\t\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            if(branch === '*' || branch === '**') {\n\t              if(tree[branch]._listeners && !endReached) {\n\t                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n\t              }\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            } else if(branch === nextType) {\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n\t            } else {\n\t              // No match on this one, shift into the tree but not in the type array.\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            }\n\t          }\n\t        }\n\t        return listeners;\n\t      }\n\t\n\t      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n\t    }\n\t\n\t    xTree = tree['*'];\n\t    if (xTree) {\n\t      //\n\t      // If the listener tree will allow any match for this part,\n\t      // then recursively explore all branches of the tree\n\t      //\n\t      searchListenerTree(handlers, type, xTree, i+1);\n\t    }\n\t\n\t    xxTree = tree['**'];\n\t    if(xxTree) {\n\t      if(i < typeLength) {\n\t        if(xxTree._listeners) {\n\t          // If we have a listener on a '**', it will catch all, so add its handler.\n\t          searchListenerTree(handlers, type, xxTree, typeLength);\n\t        }\n\t\n\t        // Build arrays of matching next branches and others.\n\t        for(branch in xxTree) {\n\t          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n\t            if(branch === nextType) {\n\t              // We know the next element will match, so jump twice.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+2);\n\t            } else if(branch === currentType) {\n\t              // Current node matches, move into the tree.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+1);\n\t            } else {\n\t              isolatedBranch = {};\n\t              isolatedBranch[branch] = xxTree[branch];\n\t              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n\t            }\n\t          }\n\t        }\n\t      } else if(xxTree._listeners) {\n\t        // We have reached the end and still on a '**'\n\t        searchListenerTree(handlers, type, xxTree, typeLength);\n\t      } else if(xxTree['*'] && xxTree['*']._listeners) {\n\t        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n\t      }\n\t    }\n\t\n\t    return listeners;\n\t  }\n\t\n\t  function growListenerTree(type, listener) {\n\t\n\t    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t\n\t    //\n\t    // Looks for two consecutive '**', if so, don't add the event at all.\n\t    //\n\t    for(var i = 0, len = type.length; i+1 < len; i++) {\n\t      if(type[i] === '**' && type[i+1] === '**') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    var tree = this.listenerTree;\n\t    var name = type.shift();\n\t\n\t    while (name) {\n\t\n\t      if (!tree[name]) {\n\t        tree[name] = {};\n\t      }\n\t\n\t      tree = tree[name];\n\t\n\t      if (type.length === 0) {\n\t\n\t        if (!tree._listeners) {\n\t          tree._listeners = listener;\n\t        }\n\t        else if(typeof tree._listeners === 'function') {\n\t          tree._listeners = [tree._listeners, listener];\n\t        }\n\t        else if (isArray(tree._listeners)) {\n\t\n\t          tree._listeners.push(listener);\n\t\n\t          if (!tree._listeners.warned) {\n\t\n\t            var m = defaultMaxListeners;\n\t\n\t            if (typeof this._events.maxListeners !== 'undefined') {\n\t              m = this._events.maxListeners;\n\t            }\n\t\n\t            if (m > 0 && tree._listeners.length > m) {\n\t\n\t              tree._listeners.warned = true;\n\t              console.error('(node) warning: possible EventEmitter memory ' +\n\t                            'leak detected. %d listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit.',\n\t                            tree._listeners.length);\n\t              console.trace();\n\t            }\n\t          }\n\t        }\n\t        return true;\n\t      }\n\t      name = type.shift();\n\t    }\n\t    return true;\n\t  }\n\t\n\t  // By default EventEmitters will print a warning if more than\n\t  // 10 listeners are added to it. This is a useful default which\n\t  // helps finding memory leaks.\n\t  //\n\t  // Obviously not all Emitters should be limited to 10. This function allows\n\t  // that to be increased. Set to zero for unlimited.\n\t\n\t  EventEmitter.prototype.delimiter = '.';\n\t\n\t  EventEmitter.prototype.setMaxListeners = function(n) {\n\t    this._events || init.call(this);\n\t    this._events.maxListeners = n;\n\t    if (!this._conf) this._conf = {};\n\t    this._conf.maxListeners = n;\n\t  };\n\t\n\t  EventEmitter.prototype.event = '';\n\t\n\t  EventEmitter.prototype.once = function(event, fn) {\n\t    this.many(event, 1, fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.many = function(event, ttl, fn) {\n\t    var self = this;\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('many only accepts instances of Function');\n\t    }\n\t\n\t    function listener() {\n\t      if (--ttl === 0) {\n\t        self.off(event, listener);\n\t      }\n\t      fn.apply(this, arguments);\n\t    }\n\t\n\t    listener._origin = fn;\n\t\n\t    this.on(event, listener);\n\t\n\t    return self;\n\t  };\n\t\n\t  EventEmitter.prototype.emit = function() {\n\t\n\t    this._events || init.call(this);\n\t\n\t    var type = arguments[0];\n\t\n\t    if (type === 'newListener' && !this.newListener) {\n\t      if (!this._events.newListener) { return false; }\n\t    }\n\t\n\t    // Loop through the *_all* functions and invoke them.\n\t    if (this._all) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t      for (i = 0, l = this._all.length; i < l; i++) {\n\t        this.event = type;\n\t        this._all[i].apply(this, args);\n\t      }\n\t    }\n\t\n\t    // If there is no 'error' event listener then throw.\n\t    if (type === 'error') {\n\t\n\t      if (!this._all &&\n\t        !this._events.error &&\n\t        !(this.wildcard && this.listenerTree.error)) {\n\t\n\t        if (arguments[1] instanceof Error) {\n\t          throw arguments[1]; // Unhandled 'error' event\n\t        } else {\n\t          throw new Error(\"Uncaught, unspecified 'error' event.\");\n\t        }\n\t        return false;\n\t      }\n\t    }\n\t\n\t    var handler;\n\t\n\t    if(this.wildcard) {\n\t      handler = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      handler = this._events[type];\n\t    }\n\t\n\t    if (typeof handler === 'function') {\n\t      this.event = type;\n\t      if (arguments.length === 1) {\n\t        handler.call(this);\n\t      }\n\t      else if (arguments.length > 1)\n\t        switch (arguments.length) {\n\t          case 2:\n\t            handler.call(this, arguments[1]);\n\t            break;\n\t          case 3:\n\t            handler.call(this, arguments[1], arguments[2]);\n\t            break;\n\t          // slower\n\t          default:\n\t            var l = arguments.length;\n\t            var args = new Array(l - 1);\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t            handler.apply(this, args);\n\t        }\n\t      return true;\n\t    }\n\t    else if (handler) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t\n\t      var listeners = handler.slice();\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        this.event = type;\n\t        listeners[i].apply(this, args);\n\t      }\n\t      return (listeners.length > 0) || !!this._all;\n\t    }\n\t    else {\n\t      return !!this._all;\n\t    }\n\t\n\t  };\n\t\n\t  EventEmitter.prototype.on = function(type, listener) {\n\t\n\t    if (typeof type === 'function') {\n\t      this.onAny(type);\n\t      return this;\n\t    }\n\t\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('on only accepts instances of Function');\n\t    }\n\t    this._events || init.call(this);\n\t\n\t    // To avoid recursion in the case that type == \"newListeners\"! Before\n\t    // adding it to the listeners, first emit \"newListeners\".\n\t    this.emit('newListener', type, listener);\n\t\n\t    if(this.wildcard) {\n\t      growListenerTree.call(this, type, listener);\n\t      return this;\n\t    }\n\t\n\t    if (!this._events[type]) {\n\t      // Optimize the case of one listener. Don't need the extra array object.\n\t      this._events[type] = listener;\n\t    }\n\t    else if(typeof this._events[type] === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      this._events[type] = [this._events[type], listener];\n\t    }\n\t    else if (isArray(this._events[type])) {\n\t      // If we've already got an array, just append.\n\t      this._events[type].push(listener);\n\t\n\t      // Check for listener leak\n\t      if (!this._events[type].warned) {\n\t\n\t        var m = defaultMaxListeners;\n\t\n\t        if (typeof this._events.maxListeners !== 'undefined') {\n\t          m = this._events.maxListeners;\n\t        }\n\t\n\t        if (m > 0 && this._events[type].length > m) {\n\t\n\t          this._events[type].warned = true;\n\t          console.error('(node) warning: possible EventEmitter memory ' +\n\t                        'leak detected. %d listeners added. ' +\n\t                        'Use emitter.setMaxListeners() to increase limit.',\n\t                        this._events[type].length);\n\t          console.trace();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.onAny = function(fn) {\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('onAny only accepts instances of Function');\n\t    }\n\t\n\t    if(!this._all) {\n\t      this._all = [];\n\t    }\n\t\n\t    // Add the function to the event listener collection.\n\t    this._all.push(fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  EventEmitter.prototype.off = function(type, listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('removeListener only takes instances of Function');\n\t    }\n\t\n\t    var handlers,leafs=[];\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      // does not use listeners(), so no side effect of creating _events[type]\n\t      if (!this._events[type]) return this;\n\t      handlers = this._events[type];\n\t      leafs.push({_listeners:handlers});\n\t    }\n\t\n\t    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t      var leaf = leafs[iLeaf];\n\t      handlers = leaf._listeners;\n\t      if (isArray(handlers)) {\n\t\n\t        var position = -1;\n\t\n\t        for (var i = 0, length = handlers.length; i < length; i++) {\n\t          if (handlers[i] === listener ||\n\t            (handlers[i].listener && handlers[i].listener === listener) ||\n\t            (handlers[i]._origin && handlers[i]._origin === listener)) {\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (position < 0) {\n\t          continue;\n\t        }\n\t\n\t        if(this.wildcard) {\n\t          leaf._listeners.splice(position, 1);\n\t        }\n\t        else {\n\t          this._events[type].splice(position, 1);\n\t        }\n\t\n\t        if (handlers.length === 0) {\n\t          if(this.wildcard) {\n\t            delete leaf._listeners;\n\t          }\n\t          else {\n\t            delete this._events[type];\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      else if (handlers === listener ||\n\t        (handlers.listener && handlers.listener === listener) ||\n\t        (handlers._origin && handlers._origin === listener)) {\n\t        if(this.wildcard) {\n\t          delete leaf._listeners;\n\t        }\n\t        else {\n\t          delete this._events[type];\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.offAny = function(fn) {\n\t    var i = 0, l = 0, fns;\n\t    if (fn && this._all && this._all.length > 0) {\n\t      fns = this._all;\n\t      for(i = 0, l = fns.length; i < l; i++) {\n\t        if(fn === fns[i]) {\n\t          fns.splice(i, 1);\n\t          return this;\n\t        }\n\t      }\n\t    } else {\n\t      this._all = [];\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\t\n\t  EventEmitter.prototype.removeAllListeners = function(type) {\n\t    if (arguments.length === 0) {\n\t      !this._events || init.call(this);\n\t      return this;\n\t    }\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t\n\t      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t        var leaf = leafs[iLeaf];\n\t        leaf._listeners = null;\n\t      }\n\t    }\n\t    else {\n\t      if (!this._events[type]) return this;\n\t      this._events[type] = null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.listeners = function(type) {\n\t    if(this.wildcard) {\n\t      var handlers = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n\t      return handlers;\n\t    }\n\t\n\t    this._events || init.call(this);\n\t\n\t    if (!this._events[type]) this._events[type] = [];\n\t    if (!isArray(this._events[type])) {\n\t      this._events[type] = [this._events[type]];\n\t    }\n\t    return this._events[type];\n\t  };\n\t\n\t  EventEmitter.prototype.listenersAny = function() {\n\t\n\t    if(this._all) {\n\t      return this._all;\n\t    }\n\t    else {\n\t      return [];\n\t    }\n\t\n\t  };\n\t\n\t  if (true) {\n\t     // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return EventEmitter;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // CommonJS\n\t    exports.EventEmitter2 = EventEmitter;\n\t  }\n\t  else {\n\t    // Browser global.\n\t    window.EventEmitter2 = EventEmitter;\n\t  }\n\t}();\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"Psionic\"] = __webpack_require__(2);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** psionic.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1995fc6ad765e8bd4116\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-promise/dist/es6-promise.js\n ** module id = 1\n ** module chunks = 0\n **/","\nmodule.exports = {\n  webSocket: require('./websocket-browser')\n};\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar Promise = typeof global.Promise === 'undefined' ? require('es6-promise').Promise : global.Promise;\nvar EventEmitter = require('eventemitter2');\nif (EventEmitter.EventEmitter2) EventEmitter = EventEmitter.EventEmitter2;\nvar FN_KEYWORD = 'psionic!function';\nvar slice = Array.prototype.slice;\n\nexports.createClient = function createClient(opts) {\n  var client = {}, protectedKeys = null;\n  client.events = new EventEmitter();\n  client.state = new EventEmitter();\n  client.state.setMaxListeners(100);\n  client.state.callId = 0;\n  client.state.describe = opts ? opts.describe : undefined;\n  client.close = function () { client.state.emit('close'); }\n\n  client.state['@describe'] = function parseIncomingDescription(desc) {\n    var remoteDescription = deserializeDescription(client, desc || {});\n    Object.keys(client).forEach(function (key) {\n      if (protectedKeys.indexOf(key) === -1) {\n        delete client[key];\n      }\n    });\n    Object.keys(remoteDescription).forEach(function (key) {\n      if (protectedKeys.indexOf(key) === -1) {\n        client[key] = remoteDescription[key];\n      }\n    });\n    client.state.emit('describe');\n  };\n\n  client.state['@emit'] = function () {\n    client.events.emit.apply(client.events, arguments);\n  };\n\n  client.emit = createRpcInvoker(client, '@emit');\n\n  client.describe = function (value) {\n    client.state.describe = value;\n    return createRpcInvoker(client, '@describe')(serializeDescription(value));\n  };\n\n  client.state.on('open', function () {\n    return createRpcInvoker(client, '@describe', false)(serializeDescription(client.state.describe));\n  });\n\n  client.state.on('message', function(msg) { onMessage(client, msg); });\n  protectedKeys = Object.keys(client);\n  client.state['@describe']();\n  return client;\n};\n\nfunction serializeDescription(description) {\n  if (!description) return;\n  return JSON.parse(JSON.stringify(description, function (key, value) {\n    if (value instanceof Function) return FN_KEYWORD;\n    return value;\n  }));\n};\n\nfunction deserializeDescription(client, description) {\n  return (function createInvokers(obj, prefix) {\n    Object.keys(obj).forEach(function (key) {\n      if (obj[key] === FN_KEYWORD) {\n        obj[key] = createRpcInvoker(client, prefix + key);\n      } else if (typeof obj[key] === 'object') {\n        createInvokers(obj[key], prefix + key + '.');\n      }\n    });\n    return obj;\n  })(description, '');\n};\n\nfunction createRpcInvoker(client, name, awaits) {\n  function awaitConnection() {\n    if (awaits === false) return Promise.resolve(true);\n    if (client.state.connected) return Promise.resolve(true);\n    else return new Promise(function (resolve) { client.state.once('connect', resolve); });\n  }\n\n  return function rpc() {\n    var id, args, json;\n    try {\n      id = client.state.callId = (client.state.callId + 1) % (-(1<<31));\n      args = Array.prototype.slice.call(arguments);\n      json = { id: id, name: name, args: args };\n    } catch(ex) { return Promise.reject(ex); }\n\n    return awaitConnection().then(function () {\n      return new Promise(function (resolve, reject) {\n        client.state.once('disconnect', onClose);\n        client.state.once('result:' + id, onResult);\n        client.state.emit('send', json);\n        function onResult(data) {\n          client.state.removeListener('disconnect', onClose);\n          if (!data.error) return resolve(data.result);\n          var error = new Error('when calling ' + name + ': ' + data.error.message);\n          error.code = data.error.code;\n          reject(error);\n        }\n        function onClose() {\n          client.state.removeListener('result:' + id, onResult);\n          reject(new Error('connection disconnect'));\n        }\n      });\n    });\n  }\n};\n\nfunction onMessage(client, msg) {\n  var data = null;\n  try {\n    data = JSON.parse(msg.substring ? msg : msg.data);\n  } catch (ex) {\n    client.state.emit('send', { error: { code: -32700, message: ex.message } });\n    return;\n  }\n\n  if (!('name' in data)) {\n    client.state.emit('result:' + data.id, data);\n  } else {\n    wrapInvocation(data.name, data.args)\n    .then(function (result) {\n      client.state.emit('send', { id: data.id, result: result });\n    }, function (ex) {\n      typeof console !== 'undefined' && console.error(ex.stack);\n      client.state.emit('send', { id: data.id, error: { code: ex.code || -32000, message: ex.friendlyMessage || 'Unhandled error' } });\n    });\n  }\n\n  function wrapInvocation(name, args) {\n    return new Promise(function (resolve, reject) {\n      var target = null\n      if (name[0] === '@' && client.state[name]) {\n        target = client.state[name];\n      } else {\n        var parts = (name || '').split('.');\n        var target = client.state.describe || {};\n        for (var i=0; target && i<parts.length; ++i) {\n          target = target[parts[i]];\n        }\n      }\n      if (!(target instanceof Function)) {\n        var error = new Error('Function not found: ' + name);\n        error.friendlyMessage = error.message;\n        error.code = -32601;\n        reject(error);\n      } else {\n        try { resolve(target.apply(client, args)); }\n        catch (ex) { reject(ex); }\n      }\n    });\n  };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/shared.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\nvar Promise = typeof global.Promise === 'undefined' ? require('es6-promise').Promise : global.Promise;\nvar shared = require('../shared');\n\nmodule.exports = function connect(opts, clientOpts) {\n  return new Promise(function (resolve, reject) {\n    var backoff = 0, socket, reconnecting, closing;\n    var client = shared.createClient(clientOpts);\n    client.close = function () { closing = true; if (socket) socket.close(); };\n    client.state.on('send', function(msg) { socket.send(JSON.stringify(msg)); });\n\n    (function createSocket() {\n      socket = new WebSocket(opts);\n      socket.onmessage = function (msg) {\n        client.state.emit('message', msg.data);\n      };\n\n      socket.onopen = function () {\n        if (closing) return socket.close();\n        backoff = 0;\n        client.state.emit('open');\n        client.state.once('describe', function() {\n          client.state.connected = true;\n          Promise.resolve(opts.connect instanceof Function ? opts.connect(client, reconnecting) : null)\n            .then(function () {\n              client.state.emit('connect');\n              resolve(client);\n            });\n          reconnecting = true;\n        });\n      };\n\n      socket.onclose = function () {\n        if (closing) client.state.emit('close');\n        client.state.connected = false;\n        client.state.emit('disconnect');\n        if (closing) return;\n        setTimeout(createSocket, 100 * (backoff * 20));\n        backoff = Math.min(backoff + 1, 5);\n      }\n    })();\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/websocket-browser/client.js\n ** module id = 4\n ** module chunks = 0\n **/","exports.connect = require('./client');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/websocket-browser/index.js\n ** module id = 5\n ** module chunks = 0\n **/","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter2/lib/eventemitter2.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = global[\"Psionic\"] = require(\"-!/Users/jd/src/personal/node-psionic/lib/browser.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/expose-loader?Psionic!./lib/browser.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}