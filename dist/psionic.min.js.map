{"version":3,"sources":["webpack:///psionic.min.js","webpack:///webpack/bootstrap 85ff0aea9bd4030daf01","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///./lib/browser.js","webpack:///./lib/shared.js","webpack:///./lib/websocket-browser/client.js","webpack:///./lib/websocket-browser/index.js","webpack:///./~/events/events.js","webpack:///./lib/browser.js?c62a","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","process","global","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$utils$$isMaybeThenable","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","node","document","createTextNode","observe","characterData","data","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","setTimeout","i","lib$es6$promise$asap$$len","callback","lib$es6$promise$asap$$queue","arg","undefined","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","e","lib$es6$promise$$internal$$noop","lib$es6$promise$$internal$$selfFulfillment","TypeError","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","promise","then","error","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","value","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","_state","lib$es6$promise$$internal$$FULFILLED","_result","lib$es6$promise$$internal$$REJECTED","lib$es6$promise$$internal$$subscribe","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","constructor","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","length","parent","child","onFulfillment","onRejection","subscribers","settled","detail","lib$es6$promise$$internal$$invokeCallback","lib$es6$promise$$internal$$ErrorObject","this","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$enumerator$$Enumerator","Constructor","input","enumerator","_instanceConstructor","_validateInput","_input","_remaining","_init","_enumerate","_validationError","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","resolve","lib$es6$promise$promise$resolve$$resolve","object","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","_id","lib$es6$promise$promise$$counter","lib$es6$promise$polyfill$$polyfill","local","self","Function","Error","P","Promise","Object","prototype","toString","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","Array","isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","window","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","_eachEntry","entry","_settledAt","_willSettleAt","state","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$resolve$$default","lib$es6$promise$promise$reject$$default","all","race","reject","_setScheduler","_setAsap","_asap","result","arguments","catch","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","webSocket","serializeDescription","description","JSON","parse","stringify","key","FN_KEYWORD","deserializeDescription","client","createInvokers","obj","prefix","keys","forEach","createRpcInvoker","name","awaits","awaitConnection","connected","once","args","json","callId","slice","ex","onResult","removeListener","onClose","message","code","emit","onMessage","msg","wrapInvocation","target","parts","split","describe","apply","friendlyMessage","substring","console","stack","EventEmitter","createClient","opts","protectedKeys","events","setMaxListeners","close","desc","remoteDescription","indexOf","on","shared","clientOpts","socket","reconnecting","closing","backoff","send","createSocket","WebSocket","onopen","connect","onclose","Math","min","_events","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","n","isNaN","type","er","handler","len","listeners","addListener","listener","newListener","push","warned","trace","g","fired","list","position","splice","removeAllListeners","ret","listenerCount","evlistener","emitter","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","array","noop","title","browser","env","argv","version","versions","off","binding","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths","children"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GAE/B,GAAgBW,IErDjB,SAAAC,EAAAC,EAAAT;;;;;;;CAQA,WACA,YACA,SAAAU,GAAAC,GACA,wBAAAA,IAAA,gBAAAA,IAAA,OAAAA,EAGA,QAAAC,GAAAD,GACA,wBAAAA,GAGA,QAAAE,GAAAF,GACA,sBAAAA,IAAA,OAAAA,EAkCA,QAAAG,GAAAC,GACAC,EAAAD,EAGA,QAAAE,GAAAC,GACAC,EAAAD,EAcA,QAAAE,KAGA,kBACAZ,EAAAa,SAAAC,IAKA,QAAAC,KACA,kBACAC,EAAAF,IAIA,QAAAG,KACA,GAAAC,GAAA,EACAC,EAAA,GAAAC,IAAAN,GACAO,EAAAC,SAAAC,eAAA,GAGA,OAFAJ,GAAAK,QAAAH,GAA8BI,eAAA,IAE9B,WACAJ,EAAAK,KAAAR,MAAA,GAKA,QAAAS,KACA,GAAAC,GAAA,GAAAC,eAEA,OADAD,GAAAE,MAAAC,UAAAjB,EACA,WACAc,EAAAI,MAAAC,YAAA,IAIA,QAAAC,KACA,kBACAC,WAAArB,EAAA,IAKA,QAAAA,KACA,OAAAsB,GAAA,EAAqBC,EAAAD,EAA+BA,GAAA,GACpD,GAAAE,GAAAC,GAAAH,GACAI,EAAAD,GAAAH,EAAA,EAEAE,GAAAE,GAEAD,GAAAH,GAAAK,OACAF,GAAAH,EAAA,GAAAK,OAGAJ,EAAA,EAGA,QAAAK,KACA,IACA,GACAC,GAAAvD,EAAA,GAEA,OADA4B,GAAA2B,EAAAC,WAAAD,EAAAE,aACA9B,IACO,MAAA+B,GACP,MAAAZ,MAkBA,QAAAa,MAQA,QAAAC,KACA,UAAAC,WAAA,4CAGA,QAAAC,KACA,UAAAD,WAAA,wDAGA,QAAAE,GAAAC,GACA,IACA,MAAAA,GAAAC,KACO,MAAAC,GAEP,MADAC,IAAAD,QACAC,IAIA,QAAAC,GAAAH,EAAAI,EAAAC,EAAAC,GACA,IACAN,EAAA1D,KAAA8D,EAAAC,EAAAC,GACO,MAAAb,GACP,MAAAA,IAIA,QAAAc,GAAAR,EAAAS,EAAAR,GACA1C,EAAA,SAAAyC,GACA,GAAAU,IAAA,EACAR,EAAAE,EAAAH,EAAAQ,EAAA,SAAAJ,GACAK,IACAA,GAAA,EACAD,IAAAJ,EACAM,EAAAX,EAAAK,GAEAO,EAAAZ,EAAAK,KAES,SAAAQ,GACTH,IACAA,GAAA,EAEAI,EAAAd,EAAAa,KACS,YAAAb,EAAAe,QAAA,sBAETL,GAAAR,IACAQ,GAAA,EACAI,EAAAd,EAAAE,KAEOF,GAGP,QAAAgB,GAAAhB,EAAAS,GACAA,EAAAQ,SAAAC,GACAN,EAAAZ,EAAAS,EAAAU,SACOV,EAAAQ,SAAAG,GACPN,EAAAd,EAAAS,EAAAU,SAEAE,EAAAZ,EAAApB,OAAA,SAAAgB,GACAM,EAAAX,EAAAK,IACS,SAAAQ,GACTC,EAAAd,EAAAa,KAKA,QAAAS,GAAAtB,EAAAuB,GACA,GAAAA,EAAAC,cAAAxB,EAAAwB,YACAR,EAAAhB,EAAAuB,OACO,CACP,GAAAtB,GAAAF,EAAAwB,EAEAtB,KAAAE,GACAW,EAAAd,EAAAG,GAAAD,OACSb,SAAAY,EACTW,EAAAZ,EAAAuB,GACSvE,EAAAiD,GACTO,EAAAR,EAAAuB,EAAAtB,GAEAW,EAAAZ,EAAAuB,IAKA,QAAAZ,GAAAX,EAAAK,GACAL,IAAAK,EACAS,EAAAd,EAAAJ,KACO9C,EAAAuD,GACPiB,EAAAtB,EAAAK,GAEAO,EAAAZ,EAAAK,GAIA,QAAAoB,GAAAzB,GACAA,EAAA0B,UACA1B,EAAA0B,SAAA1B,EAAAmB,SAGAQ,EAAA3B,GAGA,QAAAY,GAAAZ,EAAAK,GACAL,EAAAiB,SAAAW,KAEA5B,EAAAmB,QAAAd,EACAL,EAAAiB,OAAAC,GAEA,IAAAlB,EAAA6B,aAAAC,QACAvE,EAAAoE,EAAA3B,IAIA,QAAAc,GAAAd,EAAAa,GACAb,EAAAiB,SAAAW,KACA5B,EAAAiB,OAAAG,GACApB,EAAAmB,QAAAN,EAEAtD,EAAAkE,EAAAzB,IAGA,QAAAqB,GAAAU,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAJ,EAAAF,aACAC,EAAAK,EAAAL,MAEAC,GAAAL,SAAA,KAEAS,EAAAL,GAAAE,EACAG,EAAAL,EAAAZ,IAAAe,EACAE,EAAAL,EAAAV,IAAAc,EAEA,IAAAJ,GAAAC,EAAAd,QACA1D,EAAAoE,EAAAI,GAIA,QAAAJ,GAAA3B,GACA,GAAAmC,GAAAnC,EAAA6B,aACAO,EAAApC,EAAAiB,MAEA,QAAAkB,EAAAL,OAAA,CAIA,OAFAE,GAAA9C,EAAAmD,EAAArC,EAAAmB,QAEAnC,EAAA,EAAqBA,EAAAmD,EAAAL,OAAwB9C,GAAA,EAC7CgD,EAAAG,EAAAnD,GACAE,EAAAiD,EAAAnD,EAAAoD,GAEAJ,EACAM,EAAAF,EAAAJ,EAAA9C,EAAAmD,GAEAnD,EAAAmD,EAIArC,GAAA6B,aAAAC,OAAA,GAGA,QAAAS,KACAC,KAAAtC,MAAA,KAKA,QAAAuC,GAAAvD,EAAAmD,GACA,IACA,MAAAnD,GAAAmD,GACO,MAAA3C,GAEP,MADAgD,IAAAxC,MAAAR,EACAgD,IAIA,QAAAJ,GAAAF,EAAApC,EAAAd,EAAAmD,GACA,GACAhC,GAAAH,EAAAyC,EAAAC,EADAC,EAAA7F,EAAAkC,EAGA,IAAA2D,GAWA,GAVAxC,EAAAoC,EAAAvD,EAAAmD,GAEAhC,IAAAqC,IACAE,GAAA,EACA1C,EAAAG,EAAAH,MACAG,EAAA,MAEAsC,GAAA,EAGA3C,IAAAK,EAEA,WADAS,GAAAd,EAAAF,SAKAO,GAAAgC,EACAM,GAAA,CAGA3C,GAAAiB,SAAAW,KAEOiB,GAAAF,EACPhC,EAAAX,EAAAK,GACOuC,EACP9B,EAAAd,EAAAE,GACOkC,IAAAlB,GACPN,EAAAZ,EAAAK,GACO+B,IAAAhB,IACPN,EAAAd,EAAAK,IAIA,QAAAyC,GAAA9C,EAAA+C,GACA,IACAA,EAAA,SAAA1C,GACAM,EAAAX,EAAAK,IACS,SAAAQ,GACTC,EAAAd,EAAAa,KAEO,MAAAnB,GACPoB,EAAAd,EAAAN,IAIA,QAAAsD,GAAAC,EAAAC,GACA,GAAAC,GAAAX,IAEAW,GAAAC,qBAAAH,EACAE,EAAAnD,QAAA,GAAAiD,GAAAtD,GAEAwD,EAAAE,eAAAH,IACAC,EAAAG,OAAAJ,EACAC,EAAArB,OAAAoB,EAAApB,OACAqB,EAAAI,WAAAL,EAAApB,OAEAqB,EAAAK,QAEA,IAAAL,EAAArB,OACAlB,EAAAuC,EAAAnD,QAAAmD,EAAAhC,UAEAgC,EAAArB,OAAAqB,EAAArB,QAAA,EACAqB,EAAAM,aACA,IAAAN,EAAAI,YACA3C,EAAAuC,EAAAnD,QAAAmD,EAAAhC,WAIAL,EAAAqC,EAAAnD,QAAAmD,EAAAO,oBA2EA,QAAAC,GAAAC,GACA,UAAAC,IAAArB,KAAAoB,GAAA5D,QAGA,QAAA8D,GAAAF,GAaA,QAAA3B,GAAA5B,GACAM,EAAAX,EAAAK,GAGA,QAAA6B,GAAArB,GACAC,EAAAd,EAAAa,GAhBA,GAAAoC,GAAAT,KAEAxC,EAAA,GAAAiD,GAAAtD,EAEA,KAAAoE,EAAAH,GAEA,MADA9C,GAAAd,EAAA,GAAAH,WAAA,oCACAG,CAaA,QAVA8B,GAAA8B,EAAA9B,OAUA9C,EAAA,EAAqBgB,EAAAiB,SAAAW,IAAAE,EAAA9C,EAAqEA,IAC1FqC,EAAA4B,EAAAe,QAAAJ,EAAA5E,IAAAK,OAAA4C,EAAAC,EAGA,OAAAlC,GAGA,QAAAiE,GAAAC,GAEA,GAAAjB,GAAAT,IAEA,IAAA0B,GAAA,gBAAAA,MAAA1C,cAAAyB,EACA,MAAAiB,EAGA,IAAAlE,GAAA,GAAAiD,GAAAtD,EAEA,OADAgB,GAAAX,EAAAkE,GACAlE,EAGA,QAAAmE,GAAAtD,GAEA,GAAAoC,GAAAT,KACAxC,EAAA,GAAAiD,GAAAtD,EAEA,OADAmB,GAAAd,EAAAa,GACAb,EAMA,QAAAoE,KACA,SAAAvE,WAAA,sFAGA,QAAAwE,KACA,SAAAxE,WAAA,yHA2GA,QAAAyE,GAAAvB,GACAP,KAAA+B,IAAAC,KACAhC,KAAAvB,OAAA5B,OACAmD,KAAArB,QAAA9B,OACAmD,KAAAX,gBAEAlC,IAAAoD,IACA/F,EAAA+F,IACAqB,IAGA5B,eAAA8B,IACAD,IAGAvB,EAAAN,KAAAO,IAsQA,QAAA0B,KACA,GAAAC,EAEA,uBAAA7H,GACA6H,EAAA7H,MACO,uBAAA8H,MACPD,EAAAC,SAEA,KACAD,EAAAE,SAAA,iBACW,MAAAlF,GACX,SAAAmF,OAAA,4EAIA,GAAAC,GAAAJ,EAAAK,UAEAD,GAAA,qBAAAE,OAAAC,UAAAC,SAAA3I,KAAAuI,EAAAd,YAAAc,EAAAK,QAIAT,EAAAK,QAAAK,IA55BA,GAAAC,EAMAA,GALAC,MAAAC,QAKAD,MAAAC,QAJA,SAAAxI,GACA,yBAAAiI,OAAAC,UAAAC,SAAA3I,KAAAQ,GAMA,IAGAa,GACAR,EAwGAoI,EA5GAzB,EAAAsB,EACApG,EAAA,EAKA1B,MAJ2C2H,SAI3C,SAAAhG,EAAAE,GACAD,GAAAF,GAAAC,EACAC,GAAAF,EAAA,GAAAG,EACAH,GAAA,EACA,IAAAA,IAIA7B,EACAA,EAAAM,GAEA8H,OAaAC,EAAA,mBAAAC,eAAArG,OACAsG,EAAAF,MACAzH,GAAA2H,EAAAC,kBAAAD,EAAAE,uBACAC,GAAA,mBAAAlJ,IAA2E,wBAAAsI,SAAA3I,KAAAK,GAG3EmJ,GAAA,mBAAAC,oBACA,mBAAAC,gBACA,mBAAAxH,gBA4CAU,GAAA,GAAAmG,OAAA,IA6BAE,GADAM,GACAtI,IACKQ,GACLH,IACKkI,GACLxH,IACKc,SAAAoG,EACLnG,IAEAR,GAKA,IAAA8C,IAAA,OACAV,GAAA,EACAE,GAAA,EAEAjB,GAAA,GAAAoC,GAkKAG,GAAA,GAAAH,EAwFAS,GAAAiC,UAAA5B,eAAA,SAAAH,GACA,MAAAa,GAAAb,IAGAF,EAAAiC,UAAAvB,iBAAA,WACA,UAAAmB,OAAA,4CAGA7B,EAAAiC,UAAAzB,MAAA,WACAhB,KAAArB,QAAA,GAAAmE,OAAA9C,KAAAV,QAGA,IAAA+B,IAAAb,CAEAA,GAAAiC,UAAAxB,WAAA,WAOA,OANAN,GAAAX,KAEAV,EAAAqB,EAAArB,OACA9B,EAAAmD,EAAAnD,QACAkD,EAAAC,EAAAG,OAEAtE,EAAA,EAAqBgB,EAAAiB,SAAAW,IAAAE,EAAA9C,EAAqEA,IAC1FmE,EAAA+C,WAAAhD,EAAAlE,OAIAgE,EAAAiC,UAAAiB,WAAA,SAAAC,EAAAnH,GACA,GAAAmE,GAAAX,KACA/F,EAAA0G,EAAAC,oBAEAnG,GAAAkJ,GACAA,EAAA3E,cAAA/E,GAAA0J,EAAAlF,SAAAW,IACAuE,EAAAzE,SAAA,KACAyB,EAAAiD,WAAAD,EAAAlF,OAAAjC,EAAAmH,EAAAhF,UAEAgC,EAAAkD,cAAA5J,EAAAuH,QAAAmC,GAAAnH,IAGAmE,EAAAI,aACAJ,EAAAhC,QAAAnC,GAAAmH,IAIAnD,EAAAiC,UAAAmB,WAAA,SAAAE,EAAAtH,EAAAqB,GACA,GAAA8C,GAAAX,KACAxC,EAAAmD,EAAAnD,OAEAA,GAAAiB,SAAAW,KACAuB,EAAAI,aAEA+C,IAAAlF,GACAN,EAAAd,EAAAK,GAEA8C,EAAAhC,QAAAnC,GAAAqB,GAIA,IAAA8C,EAAAI,YACA3C,EAAAZ,EAAAmD,EAAAhC,UAIA6B,EAAAiC,UAAAoB,cAAA,SAAArG,EAAAhB,GACA,GAAAmE,GAAAX,IAEAnB,GAAArB,EAAAX,OAAA,SAAAgB,GACA8C,EAAAiD,WAAAlF,GAAAlC,EAAAqB,IACO,SAAAQ,GACPsC,EAAAiD,WAAAhF,GAAApC,EAAA6B,KAMA,IAAA0F,IAAA5C,EA4BA6C,GAAA1C,EAaA2C,GAAAxC,EAQAyC,GAAAvC,EAEAK,GAAA,EAUAY,GAAAd,CA2HAA,GAAAqC,IAAAJ,GACAjC,EAAAsC,KAAAJ,GACAlC,EAAAN,QAAAyC,GACAnC,EAAAuC,OAAAH,GACApC,EAAAwC,cAAA5J,EACAoH,EAAAyC,SAAA1J,EACAiH,EAAA0C,MAAAzJ,EAEA+G,EAAAW,WACAzD,YAAA8C,EAmMArE,KAAA,SAAAgC,EAAAC,GACA,GAAAH,GAAAS,KACA8D,EAAAvE,EAAAd,MAEA,IAAAqF,IAAApF,KAAAe,GAAAqE,IAAAlF,KAAAc,EACA,MAAAM,KAGA,IAAAR,GAAA,GAAAQ,MAAAhB,YAAA7B,GACAsH,EAAAlF,EAAAZ,OAEA,IAAAmF,EAAA,CACA,GAAApH,GAAAgI,UAAAZ,EAAA,EACA/I,GAAA,WACA+E,EAAAgE,EAAAtE,EAAA9C,EAAA+H,SAGA5F,GAAAU,EAAAC,EAAAC,EAAAC,EAGA,OAAAF,IA8BAmF,QAAA,SAAAjF,GACA,MAAAM,MAAAvC,KAAA,KAAAiC,IA0BA,IAAAkF,IAAA3C,EAEA4C,IACAtC,QAAAK,GACAkC,SAAAF,GAIApL,GAAA,QACAW,EAAA,WAAyB,MAAA0K,KAA0C9K,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAiD,SAAA1C,IAAAP,EAAAD,QAAAQ,KAC9D,mBAAAP,MAAA,QACLA,EAAA,QAAAiL,GACK,mBAAA7E,QACLA,KAAA,WAAA6E,IAGAD,OACC7K,KAAAiG,QFwD6BjG,KAAKJ,EAASH,EAAoB,GAAK,WAAa,MAAOwG,SAAYxG,EAAoB,IAAII,KAIvH,SAASA,EAAQD,EAASH,GGhgChCI,EAAAD,SACAoL,UAAAvL,EAAA,KH2gCM,SAASI,EAAQD,EAASH,II7gChC,SAAAa,GAAA,YAmDA,SAAA2K,GAAAC,GACA,MAAAA,GACAC,KAAAC,MAAAD,KAAAE,UAAAH,EAAA,SAAAI,EAAAxH,GACA,MAAAA,aAAAuE,UAAAkD,EACAzH,KAHA,OAOA,QAAA0H,GAAAC,EAAAP,GACA,eAAAQ,GAAAC,EAAAC,GAQA,MAPAnD,QAAAoD,KAAAF,GAAAG,QAAA,SAAAR,GACAK,EAAAL,KAAAC,EACAI,EAAAL,GAAAS,EAAAN,EAAAG,EAAAN,GACO,gBAAAK,GAAAL,IACPI,EAAAC,EAAAL,GAAAM,EAAAN,EAAA,OAGAK,GACGT,EAAA,IAGH,QAAAa,GAAAN,EAAAO,EAAAC,GACA,QAAAC,KACA,MAAAD,MAAA,EAAAzD,EAAAf,SAAA,GACAgE,EAAA1B,MAAAoC,UAAA3D,EAAAf,SAAA,GACA,GAAAe,GAAA,SAAAf,GAAgDgE,EAAA1B,MAAAqC,KAAA,UAAA3E,KAGhD,kBACA,GAAA3H,GAAAuM,EAAAC,CACA,KACAxM,EAAA2L,EAAA1B,MAAAwC,QAAAd,EAAA1B,MAAAwC,OAAA,YACAF,EAAAtD,MAAAL,UAAA8D,MAAAxM,KAAA2K,WACA2B,GAAcxM,KAAAkM,OAAAK,QACT,MAAAI,GAAY,MAAAjE,GAAA8B,OAAAmC,GAEjB,MAAAP,KAAAxI,KAAA,WACA,UAAA8E,GAAA,SAAAf,EAAA6C,GAIA,QAAAoC,GAAA3K,GAEA,GADA0J,EAAA1B,MAAA4C,eAAA,aAAAC,IACA7K,EAAA4B,MAAA,MAAA8D,GAAA1F,EAAA2I,OACA,IAAA/G,GAAA,GAAA2E,OAAA,gBAAA0D,EAAA,KAAAjK,EAAA4B,MAAAkJ,QACAlJ,GAAAmJ,KAAA/K,EAAA4B,MAAAmJ,KACAxC,EAAA3G,GAEA,QAAAiJ,KACAnB,EAAA1B,MAAA4C,eAAA,UAAA7M,EAAA4M,GACApC,EAAA,GAAAhC,OAAA,0BAZAmD,EAAA1B,MAAAqC,KAAA,aAAAQ,GACAnB,EAAA1B,MAAAqC,KAAA,UAAAtM,EAAA4M,GACAjB,EAAA1B,MAAAgD,KAAA,OAAAT,QAiBA,QAAAU,GAAAvB,EAAAwB,GAqBA,QAAAC,GAAAlB,EAAAK,GACA,UAAA7D,GAAA,SAAAf,EAAA6C,GACA,GAAA6C,GAAA,IACA,UAAAnB,EAAA,IAAAP,EAAA1B,MAAAiC,GACAmB,EAAA1B,EAAA1B,MAAAiC,OAIA,QAFAoB,IAAApB,GAAA,IAAAqB,MAAA,KACAF,EAAA1B,EAAA1B,MAAAuD,aACA7K,EAAA,EAAqB0K,GAAA1K,EAAA2K,EAAA7H,SAA0B9C,EAC/C0K,IAAAC,EAAA3K,GAGA,IAAA0K,YAAA9E,UAMA,IAAaZ,EAAA0F,EAAAI,MAAA9B,EAAAY,IACb,MAAAI,GAAoBnC,EAAAmC,OAPpB,CACA,GAAA9I,GAAA,GAAA2E,OAAA,uBAAA0D,EACArI,GAAA6J,gBAAA7J,EAAAkJ,QACAlJ,EAAAmJ,KAAA,OACAxC,EAAA3G,MApCA,GAAA5B,GAAA,IACA,KACAA,EAAAoJ,KAAAC,MAAA6B,EAAAQ,UAAAR,IAAAlL,MACG,MAAA0K,GAEH,WADAhB,GAAA1B,MAAAgD,KAAA,QAA+BpJ,OAASmJ,KAAA,OAAAD,QAAAJ,EAAAI,WAIxC,QAAA9K,GAGAmL,EAAAnL,EAAAiK,KAAAjK,EAAAsK,MACA3I,KAAA,SAAAgH,GACAe,EAAA1B,MAAAgD,KAAA,QAAiCjN,GAAAiC,EAAAjC,GAAA4K,YAC5B,SAAA+B,GACL,mBAAAiB,kBAAA/J,MAAA8I,EAAAkB,OACAlC,EAAA1B,MAAAgD,KAAA,QAAiCjN,GAAAiC,EAAAjC,GAAA6D,OAAsBmJ,KAAAL,EAAAK,MAAA,MAAAD,QAAAJ,EAAAe,iBAAA,uBAPvD/B,EAAA1B,MAAAgD,KAAA,UAAAhL,EAAAjC,GAAAiC,GArHA,GAAAyG,GAAA,mBAAAlI,GAAAkI,QAAA/I,EAAA,GAAA+I,QAAAlI,EAAAkI,QACAoF,EAAAnO,EAAA,GAAAmO,aACArC,EAAA,kBACAxC,OAAAL,UAAA8D,KAEA5M,GAAAiO,aAAA,SAAAC,GACA,GAAArC,MAAiBsC,EAAA,IAyCjB,OAxCAtC,GAAAuC,OAAA,GAAAJ,GACAnC,EAAA1B,MAAA,GAAA6D,GACAnC,EAAA1B,MAAAkE,gBAAA,KACAxC,EAAA1B,MAAAwC,OAAA,EACAd,EAAA1B,MAAAuD,SAAAQ,IAAAR,SAAAxK,OACA2I,EAAAyC,MAAA,WAA8BzC,EAAA1B,MAAAgD,KAAA,UAE9BtB,EAAA1B,MAAA,sBAAAoE,GACA,GAAAC,GAAA5C,EAAAC,EAAA0C,MACA1F,QAAAoD,KAAAJ,GAAAK,QAAA,SAAAR,GACA,KAAAyC,EAAAM,QAAA/C,UACAG,GAAAH,KAGA7C,OAAAoD,KAAAuC,GAAAtC,QAAA,SAAAR,GACA,KAAAyC,EAAAM,QAAA/C,KACAG,EAAAH,GAAA8C,EAAA9C,MAGAG,EAAA1B,MAAAgD,KAAA,aAGAtB,EAAA1B,MAAA,oBACA0B,EAAAuC,OAAAjB,KAAAQ,MAAA9B,EAAAuC,OAAArD,YAGAc,EAAAsB,KAAAhB,EAAAN,EAAA,SAEAA,EAAA6B,SAAA,SAAAxJ,GAEA,MADA2H,GAAA1B,MAAAuD,SAAAxJ,EACAiI,EAAAN,EAAA,aAAAR,EAAAnH,KAGA2H,EAAA1B,MAAAuE,GAAA,kBACA,MAAAvC,GAAAN,EAAA,gBAAAR,EAAAQ,EAAA1B,MAAAuD,aAGA7B,EAAA1B,MAAAuE,GAAA,mBAAArB,GAA4CD,EAAAvB,EAAAwB,KAC5Cc,EAAAtF,OAAAoD,KAAAJ,GACAA,EAAA1B,MAAA,eACA0B,KJynC8BzL,KAAKJ,EAAU,WAAa,MAAOqG,WAI3D,SAASpG,EAAQD,EAASH,IK7qChC,SAAAa,GAAA,YACA,IAAAkI,GAAA,mBAAAlI,GAAAkI,QAAA/I,EAAA,GAAA+I,QAAAlI,EAAAkI,QACA+F,EAAA9O,EAAA,EAEAI,GAAAD,QAAA,SAAAkO,EAAAU,GACA,UAAAhG,GAAA,SAAAf,EAAA6C,GACA,GAAAmE,GAAAC,EAAAC,EAAAC,EAAA,EACAnD,EAAA8C,EAAAV,aAAAW,EACA/C,GAAAyC,MAAA,WAAgCS,GAAA,EAAgBF,KAAAP,SAChDzC,EAAA1B,MAAAuE,GAAA,gBAAArB,GAA2CwB,EAAAI,KAAA1D,KAAAE,UAAA4B,MAE3C,QAAA6B,KACAL,EAAA,GAAAM,WAAAjB,GACAW,EAAArM,UAAA,SAAA6K,GACAxB,EAAA1B,MAAAgD,KAAA,UAAAE,EAAAlL,OAGA0M,EAAAO,OAAA,WACA,MAAAL,GAAAF,EAAAP,SACAU,EAAA,EACAnD,EAAA1B,MAAAgD,KAAA,YACAtB,GAAA1B,MAAAqC,KAAA,sBACAX,EAAA1B,MAAAoC,WAAA,EACA3D,EAAAf,QAAAqG,EAAAmB,kBAAA5G,UAAAyF,EAAAmB,QAAAxD,EAAAiD,GAAA,MACAhL,KAAA,WACA+H,EAAA1B,MAAAgD,KAAA,WACAtF,EAAAgE,KAEAiD,GAAA,MAIAD,EAAAS,QAAA,WACAP,GAAAlD,EAAA1B,MAAAgD,KAAA,SACAtB,EAAA1B,MAAAoC,WAAA,EACAV,EAAA1B,MAAAgD,KAAA,cACA4B,IACAnM,WAAAsM,EAAA,QAAAF,IACAA,EAAAO,KAAAC,IAAAR,EAAA,eLqrC8B5O,KAAKJ,EAAU,WAAa,MAAOqG,WAI3D,SAASpG,EAAQD,EAASH,GM/tChCG,EAAAqP,QAAAxP,EAAA,INsuCM,SAASI,EAAQD,GOjtCvB,QAAAgO,KACA3H,KAAAoJ,QAAApJ,KAAAoJ,YACApJ,KAAAqJ,cAAArJ,KAAAqJ,eAAAxM,OAoQA,QAAAyM,GAAA1M,GACA,wBAAAA,GAGA,QAAA2M,GAAA3M,GACA,sBAAAA,GAGA,QAAA4M,GAAA5M,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAA6M,GAAA7M,GACA,gBAAAA,EA/QAhD,EAAAD,QAAAgO,EAGAA,iBAEAA,EAAAlF,UAAA2G,QAAAvM,OACA8K,EAAAlF,UAAA4G,cAAAxM,OAIA8K,EAAA+B,oBAAA,GAIA/B,EAAAlF,UAAAuF,gBAAA,SAAA2B,GACA,IAAAJ,EAAAI,IAAA,EAAAA,GAAAC,MAAAD,GACA,KAAAtM,WAAA,8BAEA,OADA2C,MAAAqJ,cAAAM,EACA3J,MAGA2H,EAAAlF,UAAAqE,KAAA,SAAA+C,GACA,GAAAC,GAAAC,EAAAC,EAAA5D,EAAA5J,EAAAyN,CAMA,IAJAjK,KAAAoJ,UACApJ,KAAAoJ,YAGA,UAAAS,KACA7J,KAAAoJ,QAAA1L,OACA8L,EAAAxJ,KAAAoJ,QAAA1L,SAAAsC,KAAAoJ,QAAA1L,MAAA4B,QAAA,CAEA,GADAwK,EAAApF,UAAA,GACAoF,YAAAzH,OACA,KAAAyH,EAEA,MAAAzM,WAAA,wCAMA,GAFA0M,EAAA/J,KAAAoJ,QAAAS,GAEAJ,EAAAM,GACA,QAEA,IAAAT,EAAAS,GACA,OAAArF,UAAApF,QAEA,OACAyK,EAAAhQ,KAAAiG,KACA,MACA,QACA+J,EAAAhQ,KAAAiG,KAAA0E,UAAA,GACA,MACA,QACAqF,EAAAhQ,KAAAiG,KAAA0E,UAAA,GAAAA,UAAA,GACA,MAEA,SACA0B,EAAAtD,MAAAL,UAAA8D,MAAAxM,KAAA2K,UAAA,GACAqF,EAAAzC,MAAAtH,KAAAoG,OAEG,IAAAoD,EAAAO,GAIH,IAHA3D,EAAAtD,MAAAL,UAAA8D,MAAAxM,KAAA2K,UAAA,GACAuF,EAAAF,EAAAxD,QACAyD,EAAAC,EAAA3K,OACA9C,EAAA,EAAewN,EAAAxN,EAASA,IACxByN,EAAAzN,GAAA8K,MAAAtH,KAAAoG,EAGA,WAGAuB,EAAAlF,UAAAyH,YAAA,SAAAL,EAAAM,GACA,GAAAnQ,EAEA,KAAAsP,EAAAa,GACA,KAAA9M,WAAA,8BA2CA,OAzCA2C,MAAAoJ,UACApJ,KAAAoJ,YAIApJ,KAAAoJ,QAAAgB,aACApK,KAAA8G,KAAA,cAAA+C,EACAP,EAAAa,YACAA,cAEAnK,KAAAoJ,QAAAS,GAGAL,EAAAxJ,KAAAoJ,QAAAS,IAEA7J,KAAAoJ,QAAAS,GAAAQ,KAAAF,GAGAnK,KAAAoJ,QAAAS,IAAA7J,KAAAoJ,QAAAS,GAAAM,GANAnK,KAAAoJ,QAAAS,GAAAM,EASAX,EAAAxJ,KAAAoJ,QAAAS,MAAA7J,KAAAoJ,QAAAS,GAAAS,SAIAtQ,EAHAyP,EAAAzJ,KAAAqJ,eAGA1B,EAAA+B,oBAFA1J,KAAAqJ,cAKArP,KAAA,GAAAgG,KAAAoJ,QAAAS,GAAAvK,OAAAtF,IACAgG,KAAAoJ,QAAAS,GAAAS,QAAA,EACA7C,QAAA/J,MAAA,mIAGAsC,KAAAoJ,QAAAS,GAAAvK,QACA,kBAAAmI,SAAA8C,OAEA9C,QAAA8C,UAKAvK,MAGA2H,EAAAlF,UAAA4F,GAAAV,EAAAlF,UAAAyH,YAEAvC,EAAAlF,UAAA0D,KAAA,SAAA0D,EAAAM,GAMA,QAAAK,KACAxK,KAAA0G,eAAAmD,EAAAW,GAEAC,IACAA,GAAA,EACAN,EAAA7C,MAAAtH,KAAA0E,YAVA,IAAA4E,EAAAa,GACA,KAAA9M,WAAA,8BAEA,IAAAoN,IAAA,CAcA,OAHAD,GAAAL,WACAnK,KAAAqI,GAAAwB,EAAAW,GAEAxK,MAIA2H,EAAAlF,UAAAiE,eAAA,SAAAmD,EAAAM,GACA,GAAAO,GAAAC,EAAArL,EAAA9C,CAEA,KAAA8M,EAAAa,GACA,KAAA9M,WAAA,8BAEA,KAAA2C,KAAAoJ,UAAApJ,KAAAoJ,QAAAS,GACA,MAAA7J,KAMA,IAJA0K,EAAA1K,KAAAoJ,QAAAS,GACAvK,EAAAoL,EAAApL,OACAqL,EAAA,GAEAD,IAAAP,GACAb,EAAAoB,EAAAP,WAAAO,EAAAP,mBACAnK,MAAAoJ,QAAAS,GACA7J,KAAAoJ,QAAA1C,gBACA1G,KAAA8G,KAAA,iBAAA+C,EAAAM,OAEG,IAAAX,EAAAkB,GAAA,CACH,IAAAlO,EAAA8C,EAAoB9C,KAAA,GACpB,GAAAkO,EAAAlO,KAAA2N,GACAO,EAAAlO,GAAA2N,UAAAO,EAAAlO,GAAA2N,aAAA,CACAQ,EAAAnO,CACA,OAIA,KAAAmO,EACA,MAAA3K,KAEA,KAAA0K,EAAApL,QACAoL,EAAApL,OAAA,QACAU,MAAAoJ,QAAAS,IAEAa,EAAAE,OAAAD,EAAA,GAGA3K,KAAAoJ,QAAA1C,gBACA1G,KAAA8G,KAAA,iBAAA+C,EAAAM,GAGA,MAAAnK,OAGA2H,EAAAlF,UAAAoI,mBAAA,SAAAhB,GACA,GAAAxE,GAAA4E,CAEA,KAAAjK,KAAAoJ,QACA,MAAApJ,KAGA,KAAAA,KAAAoJ,QAAA1C,eAKA,MAJA,KAAAhC,UAAApF,OACAU,KAAAoJ,WACApJ,KAAAoJ,QAAAS,UACA7J,MAAAoJ,QAAAS,GACA7J,IAIA,QAAA0E,UAAApF,OAAA,CACA,IAAA+F,IAAArF,MAAAoJ,QACA,mBAAA/D,GACArF,KAAA6K,mBAAAxF,EAIA,OAFArF,MAAA6K,mBAAA,kBACA7K,KAAAoJ,WACApJ,KAKA,GAFAiK,EAAAjK,KAAAoJ,QAAAS,GAEAP,EAAAW,GACAjK,KAAA0G,eAAAmD,EAAAI,OACG,IAAAA,EAEH,KAAAA,EAAA3K,QACAU,KAAA0G,eAAAmD,EAAAI,IAAA3K,OAAA,GAIA,cAFAU,MAAAoJ,QAAAS,GAEA7J,MAGA2H,EAAAlF,UAAAwH,UAAA,SAAAJ,GACA,GAAAiB,EAOA,OAHAA,GAHA9K,KAAAoJ,SAAApJ,KAAAoJ,QAAAS,GAEAP,EAAAtJ,KAAAoJ,QAAAS,KACA7J,KAAAoJ,QAAAS,IAEA7J,KAAAoJ,QAAAS,GAAAtD,YAIAoB,EAAAlF,UAAAsI,cAAA,SAAAlB,GACA,GAAA7J,KAAAoJ,QAAA,CACA,GAAA4B,GAAAhL,KAAAoJ,QAAAS,EAEA,IAAAP,EAAA0B,GACA,QACA,IAAAA,EACA,MAAAA,GAAA1L,OAEA,UAGAqI,EAAAoD,cAAA,SAAAE,EAAApB,GACA,MAAAoB,GAAAF,cAAAlB,KP8vCM,SAASjQ,EAAQD,EAASH,IQthDhC,SAAAa,GAAAT,EAAAD,QAAAU,EAAA,QAAAb,EAAA,KRyhD8BO,KAAKJ,EAAU,WAAa,MAAOqG,WAI3D,SAASpG,EAAQD,GSrhDvB,QAAAuR,KACAC,GAAA,EACAC,EAAA9L,OACA+L,EAAAD,EAAAE,OAAAD,GAEAE,EAAA,GAEAF,EAAA/L,QACAkM,IAIA,QAAAA,KACA,IAAAL,EAAA,CAGA,GAAAM,GAAAlP,WAAA2O,EACAC,IAAA,CAGA,KADA,GAAAnB,GAAAqB,EAAA/L,OACA0K,GAAA,CAGA,IAFAoB,EAAAC,EACAA,OACAE,EAAAvB,GACAoB,GACAA,EAAAG,GAAAG,KAGAH,GAAA,GACAvB,EAAAqB,EAAA/L,OAEA8L,EAAA,KACAD,GAAA,EACAQ,aAAAF,IAiBA,QAAAG,GAAAC,EAAAC,GACA9L,KAAA6L,MACA7L,KAAA8L,QAYA,QAAAC,MAtEA,GAGAX,GAHAhR,EAAAR,EAAAD,WACA0R,KACAF,GAAA,EAEAI,EAAA,EAsCAnR,GAAAa,SAAA,SAAA4Q,GACA,GAAAzF,GAAA,GAAAtD,OAAA4B,UAAApF,OAAA,EACA,IAAAoF,UAAApF,OAAA,EACA,OAAA9C,GAAA,EAAuBA,EAAAkI,UAAApF,OAAsB9C,IAC7C4J,EAAA5J,EAAA,GAAAkI,UAAAlI,EAGA6O,GAAAhB,KAAA,GAAAuB,GAAAC,EAAAzF,IACA,IAAAiF,EAAA/L,QAAA6L,GACA5O,WAAAiP,EAAA,IASAI,EAAAnJ,UAAAiJ,IAAA,WACA1L,KAAA6L,IAAAvE,MAAA,KAAAtH,KAAA8L,QAEA1R,EAAA4R,MAAA,UACA5R,EAAA6R,SAAA,EACA7R,EAAA8R,OACA9R,EAAA+R,QACA/R,EAAAgS,QAAA,GACAhS,EAAAiS,YAIAjS,EAAAiO,GAAA0D,EACA3R,EAAA8P,YAAA6B,EACA3R,EAAA+L,KAAA4F,EACA3R,EAAAkS,IAAAP,EACA3R,EAAAsM,eAAAqF,EACA3R,EAAAyQ,mBAAAkB,EACA3R,EAAA0M,KAAAiF,EAEA3R,EAAAmS,QAAA,SAAAxG,GACA,SAAA1D,OAAA,qCAGAjI,EAAAoS,IAAA,WAA2B,WAC3BpS,EAAAqS,MAAA,SAAAC,GACA,SAAArK,OAAA,mCAEAjI,EAAAuS,MAAA,WAA4B,WToiDtB,SAAS/S,EAAQD,GU9nDvBC,EAAAD,QAAA,WAA6B,SAAA0I,OAAA,oCVqoDvB,SAASzI,EAAQD,GWroDvBC,EAAAD,QAAA,SAAAC,GAQA,MAPAA,GAAAgT,kBACAhT,EAAAiT,UAAA,aACAjT,EAAAkT,SAEAlT,EAAAmT,YACAnT,EAAAgT,gBAAA,GAEAhT,IX6oDM,SAASA,EAAQD","file":"psionic.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.0.2\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$toString = {}.toString;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(11);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$es6$promise$utils$$isArray(input);\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t\n\t      var length  = enumerator.length;\n\t      var promise = enumerator.promise;\n\t      var input   = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t\n\t      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          entry._onerror = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = entry;\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n\t          lib$es6$promise$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n\t          lib$es6$promise$promise$$needsNew();\n\t        }\n\t\n\t        lib$es6$promise$$internal$$initializePromise(this, resolver);\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t          return this;\n\t        }\n\t\n\t        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t        var result = parent._result;\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$es6$promise$asap$$asap(function(){\n\t            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), (function() { return this; }()), __webpack_require__(10)(module)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = {\n\t  webSocket: __webpack_require__(5)\n\t};\n\t\n\t\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar Promise = typeof global.Promise === 'undefined' ? __webpack_require__(1).Promise : global.Promise;\n\tvar EventEmitter = __webpack_require__(6).EventEmitter;\n\tvar FN_KEYWORD = 'psionic!function';\n\tvar slice = Array.prototype.slice;\n\t\n\texports.createClient = function createClient(opts) {\n\t  var client = {}, protectedKeys = null;\n\t  client.events = new EventEmitter();\n\t  client.state = new EventEmitter();\n\t  client.state.setMaxListeners(100);\n\t  client.state.callId = 0;\n\t  client.state.describe = opts ? opts.describe : undefined;\n\t  client.close = function () { client.state.emit('close'); }\n\t\n\t  client.state['@describe'] = function parseIncomingDescription(desc) {\n\t    var remoteDescription = deserializeDescription(client, desc || {});\n\t    Object.keys(client).forEach(function (key) {\n\t      if (protectedKeys.indexOf(key) === -1) {\n\t        delete client[key];\n\t      }\n\t    });\n\t    Object.keys(remoteDescription).forEach(function (key) {\n\t      if (protectedKeys.indexOf(key) === -1) {\n\t        client[key] = remoteDescription[key];\n\t      }\n\t    });\n\t    client.state.emit('describe');\n\t  };\n\t\n\t  client.state['@emit'] = function () {\n\t    client.events.emit.apply(client.events, arguments);\n\t  };\n\t\n\t  client.emit = createRpcInvoker(client, '@emit');\n\t\n\t  client.describe = function (value) {\n\t    client.state.describe = value;\n\t    return createRpcInvoker(client, '@describe')(serializeDescription(value));\n\t  };\n\t\n\t  client.state.on('open', function () {\n\t    return createRpcInvoker(client, '@describe', false)(serializeDescription(client.state.describe));\n\t  });\n\t\n\t  client.state.on('message', function(msg) { onMessage(client, msg); });\n\t  protectedKeys = Object.keys(client);\n\t  client.state['@describe']();\n\t  return client;\n\t};\n\t\n\tfunction serializeDescription(description) {\n\t  if (!description) return;\n\t  return JSON.parse(JSON.stringify(description, function (key, value) {\n\t    if (value instanceof Function) return FN_KEYWORD;\n\t    return value;\n\t  }));\n\t};\n\t\n\tfunction deserializeDescription(client, description) {\n\t  return (function createInvokers(obj, prefix) {\n\t    Object.keys(obj).forEach(function (key) {\n\t      if (obj[key] === FN_KEYWORD) {\n\t        obj[key] = createRpcInvoker(client, prefix + key);\n\t      } else if (typeof obj[key] === 'object') {\n\t        createInvokers(obj[key], prefix + key + '.');\n\t      }\n\t    });\n\t    return obj;\n\t  })(description, '');\n\t};\n\t\n\tfunction createRpcInvoker(client, name, awaits) {\n\t  function awaitConnection() {\n\t    if (awaits === false) return Promise.resolve(true);\n\t    if (client.state.connected) return Promise.resolve(true);\n\t    else return new Promise(function (resolve) { client.state.once('connect', resolve); });\n\t  }\n\t\n\t  return function rpc() {\n\t    var id, args, json;\n\t    try {\n\t      id = client.state.callId = (client.state.callId + 1) % (-(1<<31));\n\t      args = Array.prototype.slice.call(arguments);\n\t      json = { id: id, name: name, args: args };\n\t    } catch(ex) { return Promise.reject(ex); }\n\t\n\t    return awaitConnection().then(function () {\n\t      return new Promise(function (resolve, reject) {\n\t        client.state.once('disconnect', onClose);\n\t        client.state.once('result:' + id, onResult);\n\t        client.state.emit('send', json);\n\t        function onResult(data) {\n\t          client.state.removeListener('disconnect', onClose);\n\t          if (!data.error) return resolve(data.result);\n\t          var error = new Error('when calling ' + name + ': ' + data.error.message);\n\t          error.code = data.error.code;\n\t          reject(error);\n\t        }\n\t        function onClose() {\n\t          client.state.removeListener('result:' + id, onResult);\n\t          reject(new Error('connection disconnect'));\n\t        }\n\t      });\n\t    });\n\t  }\n\t};\n\t\n\tfunction onMessage(client, msg) {\n\t  var data = null;\n\t  try {\n\t    data = JSON.parse(msg.substring ? msg : msg.data);\n\t  } catch (ex) {\n\t    client.state.emit('send', { error: { code: -32700, message: ex.message } });\n\t    return;\n\t  }\n\t\n\t  if (!('name' in data)) {\n\t    client.state.emit('result:' + data.id, data);\n\t  } else {\n\t    wrapInvocation(data.name, data.args)\n\t    .then(function (result) {\n\t      client.state.emit('send', { id: data.id, result: result });\n\t    }, function (ex) {\n\t      typeof console !== 'undefined' && console.error(ex.stack);\n\t      client.state.emit('send', { id: data.id, error: { code: ex.code || -32000, message: ex.friendlyMessage || 'Unhandled error' } });\n\t    });\n\t  }\n\t\n\t  function wrapInvocation(name, args) {\n\t    return new Promise(function (resolve, reject) {\n\t      var target = null\n\t      if (name[0] === '@' && client.state[name]) {\n\t        target = client.state[name];\n\t      } else {\n\t        var parts = (name || '').split('.');\n\t        var target = client.state.describe || {};\n\t        for (var i=0; target && i<parts.length; ++i) {\n\t          target = target[parts[i]];\n\t        }\n\t      }\n\t      if (!(target instanceof Function)) {\n\t        var error = new Error('Function not found: ' + name);\n\t        error.friendlyMessage = error.message;\n\t        error.code = -32601;\n\t        reject(error);\n\t      } else {\n\t        try { resolve(target.apply(client, args)); }\n\t        catch (ex) { reject(ex); }\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar Promise = typeof global.Promise === 'undefined' ? __webpack_require__(1).Promise : global.Promise;\n\tvar shared = __webpack_require__(3);\n\t\n\tmodule.exports = function connect(opts, clientOpts) {\n\t  return new Promise(function (resolve, reject) {\n\t    var backoff = 0, socket, reconnecting, closing;\n\t    var client = shared.createClient(clientOpts);\n\t    client.close = function () { closing = true; if (socket) socket.close(); };\n\t    client.state.on('send', function(msg) { socket.send(JSON.stringify(msg)); });\n\t\n\t    (function createSocket() {\n\t      socket = new WebSocket(opts);\n\t      socket.onmessage = function (msg) {\n\t        client.state.emit('message', msg.data);\n\t      };\n\t\n\t      socket.onopen = function () {\n\t        if (closing) return socket.close();\n\t        backoff = 0;\n\t        client.state.emit('open');\n\t        client.state.once('describe', function() {\n\t          client.state.connected = true;\n\t          Promise.resolve(opts.connect instanceof Function ? opts.connect(client, reconnecting) : null)\n\t            .then(function () {\n\t              client.state.emit('connect');\n\t              resolve(client);\n\t            });\n\t          reconnecting = true;\n\t        });\n\t      };\n\t\n\t      socket.onclose = function () {\n\t        if (closing) client.state.emit('close');\n\t        client.state.connected = false;\n\t        client.state.emit('disconnect');\n\t        if (closing) return;\n\t        setTimeout(createSocket, 100 * (backoff * 20));\n\t        backoff = Math.min(backoff + 1, 5);\n\t      }\n\t    })();\n\t  });\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.connect = __webpack_require__(4);\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"Psionic\"] = __webpack_require__(2);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** psionic.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 85ff0aea9bd4030daf01\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-promise/dist/es6-promise.js\n ** module id = 1\n ** module chunks = 0\n **/","\nmodule.exports = {\n  webSocket: require('./websocket-browser')\n};\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar Promise = typeof global.Promise === 'undefined' ? require('es6-promise').Promise : global.Promise;\nvar EventEmitter = require('events').EventEmitter;\nvar FN_KEYWORD = 'psionic!function';\nvar slice = Array.prototype.slice;\n\nexports.createClient = function createClient(opts) {\n  var client = {}, protectedKeys = null;\n  client.events = new EventEmitter();\n  client.state = new EventEmitter();\n  client.state.setMaxListeners(100);\n  client.state.callId = 0;\n  client.state.describe = opts ? opts.describe : undefined;\n  client.close = function () { client.state.emit('close'); }\n\n  client.state['@describe'] = function parseIncomingDescription(desc) {\n    var remoteDescription = deserializeDescription(client, desc || {});\n    Object.keys(client).forEach(function (key) {\n      if (protectedKeys.indexOf(key) === -1) {\n        delete client[key];\n      }\n    });\n    Object.keys(remoteDescription).forEach(function (key) {\n      if (protectedKeys.indexOf(key) === -1) {\n        client[key] = remoteDescription[key];\n      }\n    });\n    client.state.emit('describe');\n  };\n\n  client.state['@emit'] = function () {\n    client.events.emit.apply(client.events, arguments);\n  };\n\n  client.emit = createRpcInvoker(client, '@emit');\n\n  client.describe = function (value) {\n    client.state.describe = value;\n    return createRpcInvoker(client, '@describe')(serializeDescription(value));\n  };\n\n  client.state.on('open', function () {\n    return createRpcInvoker(client, '@describe', false)(serializeDescription(client.state.describe));\n  });\n\n  client.state.on('message', function(msg) { onMessage(client, msg); });\n  protectedKeys = Object.keys(client);\n  client.state['@describe']();\n  return client;\n};\n\nfunction serializeDescription(description) {\n  if (!description) return;\n  return JSON.parse(JSON.stringify(description, function (key, value) {\n    if (value instanceof Function) return FN_KEYWORD;\n    return value;\n  }));\n};\n\nfunction deserializeDescription(client, description) {\n  return (function createInvokers(obj, prefix) {\n    Object.keys(obj).forEach(function (key) {\n      if (obj[key] === FN_KEYWORD) {\n        obj[key] = createRpcInvoker(client, prefix + key);\n      } else if (typeof obj[key] === 'object') {\n        createInvokers(obj[key], prefix + key + '.');\n      }\n    });\n    return obj;\n  })(description, '');\n};\n\nfunction createRpcInvoker(client, name, awaits) {\n  function awaitConnection() {\n    if (awaits === false) return Promise.resolve(true);\n    if (client.state.connected) return Promise.resolve(true);\n    else return new Promise(function (resolve) { client.state.once('connect', resolve); });\n  }\n\n  return function rpc() {\n    var id, args, json;\n    try {\n      id = client.state.callId = (client.state.callId + 1) % (-(1<<31));\n      args = Array.prototype.slice.call(arguments);\n      json = { id: id, name: name, args: args };\n    } catch(ex) { return Promise.reject(ex); }\n\n    return awaitConnection().then(function () {\n      return new Promise(function (resolve, reject) {\n        client.state.once('disconnect', onClose);\n        client.state.once('result:' + id, onResult);\n        client.state.emit('send', json);\n        function onResult(data) {\n          client.state.removeListener('disconnect', onClose);\n          if (!data.error) return resolve(data.result);\n          var error = new Error('when calling ' + name + ': ' + data.error.message);\n          error.code = data.error.code;\n          reject(error);\n        }\n        function onClose() {\n          client.state.removeListener('result:' + id, onResult);\n          reject(new Error('connection disconnect'));\n        }\n      });\n    });\n  }\n};\n\nfunction onMessage(client, msg) {\n  var data = null;\n  try {\n    data = JSON.parse(msg.substring ? msg : msg.data);\n  } catch (ex) {\n    client.state.emit('send', { error: { code: -32700, message: ex.message } });\n    return;\n  }\n\n  if (!('name' in data)) {\n    client.state.emit('result:' + data.id, data);\n  } else {\n    wrapInvocation(data.name, data.args)\n    .then(function (result) {\n      client.state.emit('send', { id: data.id, result: result });\n    }, function (ex) {\n      typeof console !== 'undefined' && console.error(ex.stack);\n      client.state.emit('send', { id: data.id, error: { code: ex.code || -32000, message: ex.friendlyMessage || 'Unhandled error' } });\n    });\n  }\n\n  function wrapInvocation(name, args) {\n    return new Promise(function (resolve, reject) {\n      var target = null\n      if (name[0] === '@' && client.state[name]) {\n        target = client.state[name];\n      } else {\n        var parts = (name || '').split('.');\n        var target = client.state.describe || {};\n        for (var i=0; target && i<parts.length; ++i) {\n          target = target[parts[i]];\n        }\n      }\n      if (!(target instanceof Function)) {\n        var error = new Error('Function not found: ' + name);\n        error.friendlyMessage = error.message;\n        error.code = -32601;\n        reject(error);\n      } else {\n        try { resolve(target.apply(client, args)); }\n        catch (ex) { reject(ex); }\n      }\n    });\n  };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/shared.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\nvar Promise = typeof global.Promise === 'undefined' ? require('es6-promise').Promise : global.Promise;\nvar shared = require('../shared');\n\nmodule.exports = function connect(opts, clientOpts) {\n  return new Promise(function (resolve, reject) {\n    var backoff = 0, socket, reconnecting, closing;\n    var client = shared.createClient(clientOpts);\n    client.close = function () { closing = true; if (socket) socket.close(); };\n    client.state.on('send', function(msg) { socket.send(JSON.stringify(msg)); });\n\n    (function createSocket() {\n      socket = new WebSocket(opts);\n      socket.onmessage = function (msg) {\n        client.state.emit('message', msg.data);\n      };\n\n      socket.onopen = function () {\n        if (closing) return socket.close();\n        backoff = 0;\n        client.state.emit('open');\n        client.state.once('describe', function() {\n          client.state.connected = true;\n          Promise.resolve(opts.connect instanceof Function ? opts.connect(client, reconnecting) : null)\n            .then(function () {\n              client.state.emit('connect');\n              resolve(client);\n            });\n          reconnecting = true;\n        });\n      };\n\n      socket.onclose = function () {\n        if (closing) client.state.emit('close');\n        client.state.connected = false;\n        client.state.emit('disconnect');\n        if (closing) return;\n        setTimeout(createSocket, 100 * (backoff * 20));\n        backoff = Math.min(backoff + 1, 5);\n      }\n    })();\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/websocket-browser/client.js\n ** module id = 4\n ** module chunks = 0\n **/","exports.connect = require('./client');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/websocket-browser/index.js\n ** module id = 5\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = global[\"Psionic\"] = require(\"-!/Users/jd/src/personal/node-reproc/lib/browser.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/expose-loader?Psionic!./lib/browser.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}